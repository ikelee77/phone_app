//** Object Detection streaming version – with GPU

/*
g++ -o server -std=c++11 main_mobilenet_server_new.cpp -I$INTEL_CVSDK_DIR/opencv/include -I$INTEL_CVSDK_DIR/deployment_tools/inference_engine/include -L$IE_PLUGINS_PATH -L$INTEL_CVSDK_DIR/opencv/lib -ldl -lopencv_core -lopencv_imgproc -lopencv_imgcodecs -linference_engine -lopencv_video -lopencv_highgui -lopencv_videoio -lX11

*/

#include <vector>
#include <memory>
#include <string>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <inference_engine.hpp>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

#include <X11/Xlib.h>

#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fstream>
#include <time.h>



const char *labels[20] = {"plane", "bicycle", "bird", "boat", "bottle", "bus", "car", "cat", "chair", "cow", "table",
			"dog", "horse", "motorcycle", "person", "plant", "sheep", "sofa", "train", "monitor"};

using namespace std;
using namespace cv;
using namespace InferenceEngine;
//modify
int kbhit(void)
{
  struct termios oldt, newt;
  int ch;
  int oldf;
  tcgetattr(STDIN_FILENO, &oldt);
  newt = oldt;
  newt.c_lflag &= ~(ICANON | ECHO);
  tcsetattr(STDIN_FILENO, TCSANOW, &newt);
  oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
  fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);
  ch = getchar();
  tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
  fcntl(STDIN_FILENO, F_SETFL, oldf);
  if(ch != EOF)
  {
    //DO whatever you like to do with this charecter ..
    ungetc(ch, stdin);
    return 1;
  }
  return 0;
}

void socketError(const char *msg) {
	perror(msg);
	exit(1);
}

int main(int argc, char *argv[]) {


	//screen size
	Display* disp = XOpenDisplay(NULL);
	Screen*  scrn = DefaultScreenOfDisplay(disp);
	int height = scrn->height;
	int width  = scrn->width;
	/*int width = GetSystemMetrics(SM_CXSCREEN);
	int height = GetSystemMetrics(SM_CYSCREEN);*/


	// ---------------------Load A Plugin for Inference Engine-

	InferenceEngine::PluginDispatcher dispatcher({""});
	InferencePlugin plugin(dispatcher.getSuitablePlugin(TargetDevice::eGPU));


	// --------------------Load IR Generated by ModelOptimizer (.xml and .bin files)------------------------

	CNNNetReader network_reader;
	
	network_reader.ReadNetwork("/home/intel/my_model/FP16/mobilenet-ssd.xml");
	network_reader.ReadWeights("/home/intel/my_model/FP16/mobilenet-ssd.bin");
	network_reader.getNetwork().setBatchSize(1);

	CNNNetwork network = network_reader.getNetwork();

	// -----------------------------Prepare input blobs-----------------------------------------------------

	auto input_info = network.getInputsInfo().begin()->second;
	auto input_name = network.getInputsInfo().begin()->first;

	input_info->setPrecision(Precision::U8);

	// ---------------------------Prepare output blobs------------------------------------------------------

	auto output_info = network.getOutputsInfo().begin()->second;
	auto output_name = network.getOutputsInfo().begin()->first;
	
	output_info->setPrecision(Precision::FP32);

	// -------------------------Loading model to the plugin and then infer----------------------------------

	auto executable_network = plugin.LoadNetwork(network, {});
	auto infer_request = executable_network.CreateInferRequest();

	auto input = infer_request.GetBlob(input_name);
	auto input_data = input->buffer().as<PrecisionTrait<Precision::U8>::value_type*>();

	char buf[256];
	// VideoCapture cap("final.mp4");//<-- usb camera or can be any video stream
	VideoCapture cap("/dev/video0");
	
	Mat frame;

	bool bret;

	if(!cap.isOpened())
	{
		cout << "can't open input device" << endl;
		return 1;
	}

	Mat ori_image, infer_image;
	//-------mail modify-------
	bret = cap.read(ori_image);	

	if(bret == false)
		return 1;






	// socket setting //
	const int portno = atoi(argv[1]);
	const int BUFFER_SIZE = 5;
	int sockfd, newsockfd, n;

	char buffer[BUFFER_SIZE];
	struct sockaddr_in serv_addr, cli_addr;
	socklen_t clilen;


	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if(sockfd < 0) socketError("Error opening Socket.");

	bzero((char *) &serv_addr, sizeof(serv_addr));

	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);

	if(bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)
		socketError("Binding Failed");

	
	while(1) {

		int found_count = 0;
		printf("waiting for client\n");
		listen(sockfd, 5);
		clilen = sizeof(cli_addr);
		newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);

		if(newsockfd < 0) socketError("Error on Accept");

		printf("accept success\n");

		bzero(buffer, BUFFER_SIZE);
		n = read(newsockfd, buffer, BUFFER_SIZE);
		
		if(n < 0) socketError("error reading");
		
		
		int target = atoi(buffer);  // Object index you want to detect;
		int prev_target = target;
		bool break_flag = false;
		printf("looking for %s, %d\n", labels[target], target);


		while(1)
		{	

			// read one frame from input stream
			cap.read(ori_image);
			

			resize(ori_image, infer_image, Size(input_info->getDims()[0], input_info->getDims()[1]));
			
			namedWindow("result",WINDOW_NORMAL);
			resizeWindow("result",width/2,(height*3/4-40));
			moveWindow("result", width/2, 0);



			size_t channels_number = input->dims()[2];
			size_t image_size = input->dims()[1] * input->dims()[0];


			for(size_t pid = 0; pid < image_size; ++pid) {
				for(size_t ch = 0; ch < channels_number; ++ch)	{
					input_data[ch*image_size+pid] = infer_image.at<Vec3b>(pid)[ch];
				}
			}

			/* Running the request synchronously */
			infer_request.Infer();

			// ---------------------------Postprocess output blobs--------------------------------------------------


			auto output = infer_request.GetBlob(output_name);

			// +++++++++++++ check proposal count and objectsize of each proposal +++++++++++
			const int maxProposalCount = output->dims()[1];
			const int objectSize = output->dims()[0];

			const Blob::Ptr output_blob = output;
			const float* detection = static_cast<PrecisionTrait<Precision::FP32>::value_type*>(output_blob->buffer());

			/* Each detection has image_id that denotes processed image */
			for (int curProposal = 0; curProposal < maxProposalCount; curProposal++) {
				float image_id = detection[curProposal * objectSize + 0];
				float label_index = detection[curProposal * objectSize + 1];
				float confidence = detection[curProposal * objectSize + 2];
				/* CPU and GPU plugins have difference in DetectionOutput layer, so we need both checks */
				if (image_id < 0 || confidence == 0) {
					continue;
				}

				float xmin = detection[curProposal * objectSize + 3] * ori_image.size().width;
				float ymin = detection[curProposal * objectSize + 4] * ori_image.size().height;
				float xmax = detection[curProposal * objectSize + 5] * ori_image.size().width;
				float ymax = detection[curProposal * objectSize + 6] * ori_image.size().height;
				
				if (confidence > 0.5) {
				/** Drawing only objects with >50% probability **/
					string stag;
					ostringstream ostr;                        
					ostr << labels[(int)label_index - 1] << ", " << fixed << setw(4) << setprecision(2) << confidence;
					string header = ostr.str();

					// cout << header << endl;
					

					// check if found target
					if ((int)label_index - 1 == target) {
						
						found_count++;

						if(found_count < 15) continue;

                        string timestamp = to_string(time(NULL));
						string imgName = "target_" + string(labels[target]) + "_" + timestamp + ".jpeg";
						printf("found target object!!\n");

						imwrite(imgName, ori_image);
						bzero(buffer, BUFFER_SIZE);	
						strncpy(buffer, "a", 1);
						write(newsockfd, buffer, strlen(buffer));


						// send image
						printf("sending image start\n");
						ifstream fin;
						fin.open(imgName, ios::in | ios::binary);
						const int MAXSIZE = 255;

						fin.seekg(0, ios::end);
						int size = fin.tellg();
						fin.seekg(0, ios::beg);

						int left = size;
						printf("file size: %d\n", size);

						while(left > 0) {
							char* buf;
							buf = new char[MAXSIZE];
							fin.read(buf, MAXSIZE); //파일 읽기

							left -= MAXSIZE;

							write(newsockfd, buf, MAXSIZE);
							delete[] buf;
						}
						fin.close();
						printf("image sending done\n");
						close(newsockfd);							
						break_flag = true;
					} else { found_count = 0; }
						
				}  	
			}


					
			if(break_flag) break;
			bzero(buffer, BUFFER_SIZE);
			strncpy(buffer, "b", 1);
			write(newsockfd, buffer, strlen(buffer));
		
			bzero(buffer, BUFFER_SIZE);
			n = read(newsockfd, buffer, BUFFER_SIZE);
			if(n < 0) {
				printf("connection reset");
				break;
			}

			target = atoi(buffer);
			if(target != prev_target) {
				printf("target reset to %s\n", labels[target]);
				prev_target = target;
			}
			bzero(buffer, BUFFER_SIZE);
			
						
			imshow("result", ori_image);
			
							
			
			if (waitKey(1) >= 13)	// enterkey
				break;
		}
		
		cvDestroyAllWindows();
	

	}

	return 0;
}
